/*
 * This source file was generated by the Gradle 'init' task
 */
package org.oclinchoco;
import org.oclinchoco.types.Source;
import org.oclinchoco.types.NavTable;
import org.oclinchoco.types.PropertyTable;
import org.oclinchoco.types.Sequence;
import org.chocosolver.solver.*;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;

import java.util.stream.IntStream;

public class ReferenceTable implements PropertyTable, NavTable {
    int rows,cols,domain;
    int minCard, maxCard; boolean has_nulls;

    Model csp;
    IntVar[][] ptr_matrix;
    IntVar[][] occ_matrix;
    IntVar[] nullptrs;
    IntVar[] sizes;

    public ReferenceTable(CSP m, int n, int nn, int c, int d){
        csp = m.csp;
        rows=n; cols=nn; domain=d;
        minCard = c; maxCard=cols;
        has_nulls = !(minCard==maxCard);

        // Variables
        if (has_nulls) ptr_matrix = csp.intVarMatrix(rows, cols, 0,domain);
            else ptr_matrix = csp.intVarMatrix(rows, cols, 1,domain);
        occ_matrix = csp.intVarMatrix(rows, domain+1, 0, cols);
        
        // Constraints
        int[] values = IntStream.range(0, d+1).toArray();
        for(int i=0;i<n;i++) 
            csp.globalCardinality(ptr_matrix[i], values, occ_matrix[i], true).post();
        
        // NavTable Variables
        nullptrs = new IntVar[nn];
        for(int i=0;i<nn;i++) nullptrs[i] = m.nullptr;

        // Collection Variables And Constraints
        sizes = new IntVar[n];
        for(int i=0;i<n;i++) sizes[i] = occ_matrix[i][0].mul(-1).add(nn).intVar();

    }

    // public static void Opposites(CSP m, ReferenceTable a, ReferenceTable b){
    //     int al = a.length;
    //     int bl = b.length;
    //     IntVar[][] aocc = m.intVarMatrix(al, bl, 0,magic);
    //     int[] avals = new int[bl];
    //     for(int i=0;i<bl;i++) avals[i]=(i);
    //     for(int i=0;i<al;i++){
    //         m.globalCardinality(a[i],avals,aocc[i],false).post();
    //     }
        
    //     IntVar[][] bocc = m.intVarMatrix(bl, al, 0,magic);
    //     int[] bvals = new int[al];
    //     for(int i=0;i<al;i++) bvals[i]=(i);
    //     for(int i=0;i<bl;i++){
    //         m.globalCardinality(b[i],bvals,bocc[i],false).post();
    //     }

    //     for(int i=0;i<al;i++) for(int j=0;j<bl;j++){
    //         m.ifOnlyIf(m.arithm(aocc[i][j], ">",0), m.arithm(bocc[j][i], ">",0));
    //     }
    // }

    //navTable Methods
    public IntVar[] navTable(){
        return ArrayUtils.concat(nullptrs, ArrayUtils.flatten(ptr_matrix));
    }
    public int cols(){return cols;}
    public int lb(){
        if(!has_nulls) return 1;
        return 0;
    }
    public int ub(){
        return domain;
    }

    class AdjList implements Source, Sequence {
        IntVar[] vars;
        IntVar size;
        private AdjList(IntVar[] vars, IntVar size){
            this.vars=vars;
            this.size=size;
        }
        public IntVar[] srcVars(){return vars;}
        public IntVar size(){return size;}
        public IntVar first(){return vars[0];}
    }
    public AdjList adjList(int objId){
        return new AdjList(ptr_matrix[objId-1],sizes[objId-1]);
    }

    public void loadData(int[][] data){
        for(int i=0;i<rows;i++) for(int j=0;j<cols;j++){
            csp.arithm(ptr_matrix[i][j], "=", data[i][j]).post();
        }
    }
}