/*
 * This source file was generated by the Gradle 'init' task
 */
package org.oclinchoco;

import org.oclinchoco.property.NavTable;
import org.oclinchoco.source.PtrSource;
import org.oclinchoco.source.Source;

import org.chocosolver.solver.*;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;

import java.util.stream.IntStream;

public class ReferenceTable implements NavTable {
    final int rows,cols,ub,lb; //number of squares and possible numbers in them
    final int minCard, maxCard; boolean has_nulls; //Reference Cardinality

    Model csp; //Choco Model
    IntVar[][] ptr_matrix;
    IntVar[][] occ_matrix;
    IntVar[] nullptrs;
    int[] values;

    public ReferenceTable(CSP m, int number_of_objects, int max_card, int min_card, int number_of_targets){
        csp = m.csp;
        minCard = min_card; maxCard=max_card;
        has_nulls = !(minCard==maxCard);

        rows=number_of_objects; cols=max_card; ub=number_of_targets;
        if(has_nulls) lb=0; else lb=1;
        
        values = IntStream.range(0, ub+1).toArray(); //possible pointer values to count with GCC (+1 for range())

        // Variables
        ptr_matrix = csp.intVarMatrix(rows, cols, lb, ub);
        occ_matrix = csp.intVarMatrix(rows, values.length, values[0], cols);
        
        // Constraints
        for(int i=0;i<rows;i++) 
            csp.globalCardinality(ptr_matrix[i], values, occ_matrix[i], true).post();//ptr model = occ model //closed because we have var for each

        // for(int i=0;i<rows;i++)for(int j=0;j<minCard;j++) csp.arithm(ptr_matrix[i][j],"!=",0).post(); //remove null ptr from the ptrs < minCard
        try{
            System.out.println("removing null pointer from variable domain");
            for(int i=0;i<rows;i++)for(int j=0;j<minCard;j++) ptr_matrix[i][j].updateLowerBound(1, null); //remove null ptr from the ptrs < minCard
        } catch(Exception e){System.out.println("Contradiction");}

        // NavTable Variables
        nullptrs = new IntVar[cols];
        for(int i=0;i<cols;i++) nullptrs[i] = m.nullptr;
    }

    // public static void Opposites(CSP m, ReferenceTable a, ReferenceTable b){        
    //     int al = a.rows;
    //     int bl = b.rows;
    //     IntVar[][] aocc = a.occ_matrix;
    //     int[] avals = new int[bl];
    //     for(int i=0;i<bl;i++) avals[i]=(i);
        
    //     IntVar[][] bocc = m.intVarMatrix(bl, al, 0,magic);
    //     int[] bvals = new int[al];
    //     for(int i=0;i<al;i++) bvals[i]=(i);


    //     for(int i=0;i<al;i++) for(int j=0;j<bl;j++){
    //         m.ifOnlyIf(m.arithm(aocc[i][j], ">",0), m.arithm(bocc[j][i], ">",0));
    //     }
    // }

    @Override //NavTable
    public IntVar[] navTable(){
        return ArrayUtils.concat(nullptrs, ArrayUtils.flatten(ptr_matrix));
    }
    @Override //NavTable
    public int cols(){return cols;}
    
    @Override //NavTable
    public int lb(){ return lb; }

    @Override //NavTable
    public int ub(){return ub;}

    class AdjList implements PtrSource {
        IntVar[] vars;
        private AdjList(IntVar[] vars){
            this.vars=vars;
        }
        @Override //PtrSource
        public IntVar[] pointers(){return vars;}
    }
    public AdjList adjList(int objId){
        return new AdjList(ptr_matrix[objId-1]);
    }


    
    public void loadData(int[][] data){
        for(int i=0;i<rows;i++) for(int j=0;j<cols;j++){
            csp.arithm(ptr_matrix[i][j], "=", data[i][j]).post();
        }
    }

    @Override
    public String toString() {
        String out = "";
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                out += ptr_matrix[i][j] + ", ";
            }
            out += "\n";
        }
        return out;
    }
}