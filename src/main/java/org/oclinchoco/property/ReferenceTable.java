/*
 * This source file was generated by the Gradle 'init' task
 */
package org.oclinchoco.property;

import org.oclinchoco.CSP;
import org.oclinchoco.navigation.NavTable;
import org.oclinchoco.source.PtrSource;
import org.oclinchoco.source.Source;

import org.chocosolver.solver.*;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;

import java.util.stream.IntStream;

public class ReferenceTable extends IntTable {
    // final int rows,cols;
    final int ub,lb; //number of squares and possible numbers in them
    // final int minCard, maxCard; boolean has_nulls; //Reference Cardinality

    IntVar[][] ptr_matrix;
    IntVar[][] occ_matrix;
    IntVar[] nullptrs;
    int[] values;

    public ReferenceTable(CSP m, int number_of_objects, int max_card, int min_card, int number_of_targets){ //has extra data because of reduced domain
        super(m, number_of_objects, min_card, max_card);

        ub=number_of_targets;
        if(has_nulls) lb=0; else lb=1;
        
        values = IntStream.range(0, ub+1).toArray(); //possible pointer values to count with GCC (+1 for range())

        // Variables
        ptr_matrix = csp.intVarMatrix(rows, cols, lb, ub);
        occ_matrix = csp.intVarMatrix(rows, values.length, values[0], cols);
        matrix = ptr_matrix;
        
        // Constraints
        for(int i=0;i<rows;i++) 
            csp.globalCardinality(ptr_matrix[i], values, occ_matrix[i], true).post();//ptr model = occ model //closed because we have var for each

        // for(int i=0;i<rows;i++)for(int j=0;j<minCard;j++) csp.arithm(ptr_matrix[i][j],"!=",0).post(); //remove null ptr from the ptrs < minCard
        try{
            // System.out.println("removing null pointer from variable domain");
            for(int i=0;i<rows;i++)for(int j=0;j<minCard;j++) ptr_matrix[i][j].updateLowerBound(1, null); //remove null ptr from the ptrs < minCard
        } catch(Exception e){System.out.println("Contradiction when removing null pointers");}

        // NavTable Variables
        nullptrs = new IntVar[cols];
        for(int i=0;i<cols;i++) nullptrs[i] = m.nullptr();
        nullrow=nullptrs; //in generalisation
    }



    //This function applies the Opposite CSP between two Reference Tables
    //say class A{B[] connectedBs opposite singleA}, class B{A singleA opposite connectedBs}
    //connectedBs being the opposite of singleA means: if for A1 connectedBs=[3,4,5], then for B3,B4 and B5 singleA=[1] 
    public static void Opposites(CSP csp, ReferenceTable a, ReferenceTable b){  
        Model m = csp.model();      
        int al = a.rows;
        IntVar[][] aocc = a.occ_matrix;
        int bl = b.rows;
        IntVar[][] bocc = b.occ_matrix;

        for(int i=0;i<al;i++) for(int j=0;j<bl;j++){
            m.ifOnlyIf(m.arithm(aocc[i][j+1], "=",0), m.arithm(bocc[j][i+1], "=",0));
        }
    }

    // @Override //NavTable
    // public IntVar[] navTable(){
    //     return ArrayUtils.concat(nullptrs, ArrayUtils.flatten(ptr_matrix));
    // }
    // @Override //NavTable
    // public int cols(){return cols;}
    
    @Override //NavTable
    public int lb(){ return lb; }

    @Override //NavTable
    public int ub(){return ub;}

    public class AdjList extends IntTableRow implements PtrSource {
        private AdjList(int objId,ReferenceTable table){
            super(objId);
        }
        @Override //PtrSource
        public IntVar[] pointers(){return ptr_matrix[objId-1];}
        @Override //PtrSource
        public int ub() {return ub;}
        @Override //Source
        public int size() {return maxCard;}

        // public void loadData(int[] data){
        //     // System.out.println("Object ID: "+objId);
        //     for(int i=0;i<cols;i++){
        //         if(data[i]!=-1){
        //             // System.out.println("AdjList LoadData");
        //             try{pointers()[i].updateBounds(data[i], data[i], null);}
        //             catch(Exception e){System.out.println("Contradiction when loading data:\nVariable Domain: "+pointers()[i]+"\nData:"+data[i] );}

        //         }
        //     }
        // }

        // public int[] getData(){
        //     int[] out = new int[table.cols];
        //     for(int i=0;i<cols;i++) out[i] = pointers()[i].getValue();
        //     return out;
        // }
    }
    public AdjList adjList(int objId){
        return new AdjList(objId,this);
    }


    
    public void loadData(int[][] data){
        for(int i=0;i<rows;i++) for(int j=0;j<cols;j++){
            try {
                ptr_matrix[i][j].updateBounds(data[i][j], data[i][j], null);
            } catch (Exception e){System.out.println("Contradiction when loading data");}
            // csp.arithm(ptr_matrix[i][j], "=", data[i][j]).post();
        }
    }

    @Override
    public String toString() {
        String out = "";
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                out += ptr_matrix[i][j] + " ";
            }
            out += "\n";
        }
        return out;
    }
}